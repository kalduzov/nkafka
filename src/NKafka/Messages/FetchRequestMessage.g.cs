//  This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// 
//  PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com
// 
//  Copyright ©  2022 Aleksey Kalduzov. All rights reserved
// 
//  Author: Aleksey Kalduzov
//  Email: alexei.kalduzov@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      https://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
// <auto-generated> THIS CODE IS AUTOMATICALLY GENERATED.  DO NOT EDIT. </auto-generated>

// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedType.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable PartialTypeWithSinglePart

#nullable enable

using NKafka.Exceptions;
using NKafka.Protocol;
using NKafka.Protocol.Buffers;
using NKafka.Protocol.Extensions;
using NKafka.Protocol.Records;
using System.Text;

namespace NKafka.Messages;

/// <summary>
/// Describes the contract for message FetchRequestMessage
/// </summary>
public sealed partial class FetchRequestMessage: IRequestMessage, IEquatable<FetchRequestMessage>
{
    /// <inheritdoc />
    public ApiKeys ApiKey => ApiKeys.Fetch;

    /// <summary>
    /// Indicates whether the request is accessed by any broker or only by the controller
    /// </summary>
    public const bool ONLY_CONTROLLER = false;

    /// <inheritdoc />
    public bool OnlyController => ONLY_CONTROLLER;

    /// <inheritdoc />
    public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

    /// <inheritdoc />
    public int IncomingBufferLength { get; private set; } = 0;

    /// <summary>
    /// The clusterId if known. This is used to validate metadata fetches prior to broker registration.
    /// </summary>
    public string? ClusterId { get; set; } = null;

    /// <summary>
    /// The broker ID of the follower, of -1 if this request is from a consumer.
    /// </summary>
    public int ReplicaId { get; set; } = 0;

    /// <summary>
    /// The maximum time in milliseconds to wait for the response.
    /// </summary>
    public int MaxWaitMs { get; set; } = 0;

    /// <summary>
    /// The minimum bytes to accumulate in the response.
    /// </summary>
    public int MinBytes { get; set; } = 0;

    /// <summary>
    /// The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.
    /// </summary>
    public int MaxBytes { get; set; } = 2147483647;

    /// <summary>
    /// This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records
    /// </summary>
    public sbyte IsolationLevel { get; set; } = 0;

    /// <summary>
    /// The fetch session ID.
    /// </summary>
    public int SessionId { get; set; } = 0;

    /// <summary>
    /// The fetch session epoch, which is used for ordering requests in a session.
    /// </summary>
    public int SessionEpoch { get; set; } = -1;

    /// <summary>
    /// The topics to fetch.
    /// </summary>
    public List<FetchTopicMessage> Topics { get; set; } = new ();

    /// <summary>
    /// In an incremental fetch request, the partitions to remove.
    /// </summary>
    public List<ForgottenTopicMessage> ForgottenTopicsData { get; set; } = new ();

    /// <summary>
    /// Rack ID of the consumer making this request
    /// </summary>
    public string RackId { get; set; } = string.Empty;

    /// <summary>
    /// The basic constructor of the message FetchRequestMessage
    /// </summary>
    public FetchRequestMessage()
    {
    }

    /// <summary>
    /// Base constructor for deserializing message FetchRequestMessage
    /// </summary>
    public FetchRequestMessage(ref BufferReader reader, ApiVersion version)
        : this()
    {
        IncomingBufferLength = reader.Length;
        Read(ref reader, version);
    }

    /// <inheritdoc />
    public void Read(ref BufferReader reader, ApiVersion version)
    {
        {
            ClusterId = null;
        }
        ReplicaId = reader.ReadInt();
        MaxWaitMs = reader.ReadInt();
        MinBytes = reader.ReadInt();
        if (version >= ApiVersion.Version3)
        {
            MaxBytes = reader.ReadInt();
        }
        else
        {
            MaxBytes = 2147483647;
        }
        if (version >= ApiVersion.Version4)
        {
            IsolationLevel = reader.ReadSByte();
        }
        else
        {
            IsolationLevel = 0;
        }
        if (version >= ApiVersion.Version7)
        {
            SessionId = reader.ReadInt();
        }
        else
        {
            SessionId = 0;
        }
        if (version >= ApiVersion.Version7)
        {
            SessionEpoch = reader.ReadInt();
        }
        else
        {
            SessionEpoch = -1;
        }
        {
            if (version >= ApiVersion.Version12)
            {
                int arrayLength;
                arrayLength = reader.ReadVarUInt() - 1;
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field Topics was serialized as null");
                }
                else
                {
                    var newCollection = new List<FetchTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new FetchTopicMessage(ref reader, version));
                    }
                    Topics = newCollection;
                }
            }
            else
            {
                int arrayLength;
                arrayLength = reader.ReadInt();
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field Topics was serialized as null");
                }
                else
                {
                    var newCollection = new List<FetchTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new FetchTopicMessage(ref reader, version));
                    }
                    Topics = newCollection;
                }
            }
        }
        if (version >= ApiVersion.Version7)
        {
            if (version >= ApiVersion.Version12)
            {
                int arrayLength;
                arrayLength = reader.ReadVarUInt() - 1;
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field ForgottenTopicsData was serialized as null");
                }
                else
                {
                    var newCollection = new List<ForgottenTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new ForgottenTopicMessage(ref reader, version));
                    }
                    ForgottenTopicsData = newCollection;
                }
            }
            else
            {
                int arrayLength;
                arrayLength = reader.ReadInt();
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field ForgottenTopicsData was serialized as null");
                }
                else
                {
                    var newCollection = new List<ForgottenTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new ForgottenTopicMessage(ref reader, version));
                    }
                    ForgottenTopicsData = newCollection;
                }
            }
        }
        else
        {
            ForgottenTopicsData = new ();
        }
        if (version >= ApiVersion.Version11)
        {
            int length;
            if (version >= ApiVersion.Version12)
            {
                length = reader.ReadVarUInt() - 1;
            }
            else
            {
                length = reader.ReadShort();
            }
            if (length < 0)
            {
                throw new Exception("non-nullable field RackId was serialized as null");
            }
            else if (length > 0x7fff)
            {
                throw new Exception($"string field RackId had invalid length {length}");
            }
            else
            {
                RackId = reader.ReadString(length);
            }
        }
        else
        {
            RackId = string.Empty;
        }
        UnknownTaggedFields = null;
        if (version >= ApiVersion.Version12)
        {
            var numTaggedFields = reader.ReadVarUInt();
            for (var t = 0; t < numTaggedFields; t++)
            {
                var tag = reader.ReadVarUInt();
                var size = reader.ReadVarUInt();
                switch (tag)
                {
                    case 0:
                    {
                        int length;
                        length = reader.ReadVarUInt() - 1;
                        if (length < 0)
                        {
                            ClusterId = null;
                        }
                        else if (length > 0x7fff)
                        {
                            throw new Exception($"string field ClusterId had invalid length {length}");
                        }
                        else
                        {
                            ClusterId = reader.ReadString(length);
                        }
                        break;
                    }
                    default:
                        UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                        break;
                }
            }
        }
    }

    /// <inheritdoc />
    public void Write(BufferWriter writer, ApiVersion version)
    {
        var numTaggedFields = 0;
        if (version >= ApiVersion.Version12)
        {
            if (ClusterId is not null)
            {
                numTaggedFields++;
            }
        }
        writer.WriteInt(ReplicaId);
        writer.WriteInt(MaxWaitMs);
        writer.WriteInt(MinBytes);
        if (version >= ApiVersion.Version3)
        {
            writer.WriteInt(MaxBytes);
        }
        if (version >= ApiVersion.Version4)
        {
            writer.WriteSByte(IsolationLevel);
        }
        if (version >= ApiVersion.Version7)
        {
            writer.WriteInt(SessionId);
        }
        if (version >= ApiVersion.Version7)
        {
            writer.WriteInt(SessionEpoch);
        }
        if (version >= ApiVersion.Version12)
        {
            writer.WriteVarUInt(Topics.Count + 1);
            foreach (var element in Topics)
            {
                element.Write(writer, version);
            }
        }
        else
        {
            writer.WriteInt(Topics.Count);
            foreach (var element in Topics)
            {
                element.Write(writer, version);
            }
        }
        if (version >= ApiVersion.Version7)
        {
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(ForgottenTopicsData.Count + 1);
                foreach (var element in ForgottenTopicsData)
                {
                    element.Write(writer, version);
                }
            }
            else
            {
                writer.WriteInt(ForgottenTopicsData.Count);
                foreach (var element in ForgottenTopicsData)
                {
                    element.Write(writer, version);
                }
            }
        }
        else
        {
            if (ForgottenTopicsData.Count != 0)
            {
                throw new UnsupportedVersionException($"Attempted to write a non-default ForgottenTopicsData at version {version}");
            }
        }
        if (version >= ApiVersion.Version11)
        {
            {
                var stringBytes = Encoding.UTF8.GetBytes(RackId);
                if (version >= ApiVersion.Version12)
                {
                    writer.WriteVarUInt(stringBytes.Length + 1);
                }
                else
                {
                    writer.WriteShort((short)stringBytes.Length);
                }
                writer.WriteBytes(stringBytes);
            }
        }
        var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
        numTaggedFields += rawWriter.FieldsCount;
        if (version >= ApiVersion.Version12)
        {
            writer.WriteVarUInt(numTaggedFields);
            if (ClusterId is not null)
            {
                writer.WriteVarUInt(0);
                var stringBytes = Encoding.UTF8.GetBytes(ClusterId);
                writer.WriteVarUInt(stringBytes.Length + (stringBytes.Length + 1).SizeOfVarUInt());
                writer.WriteVarUInt(stringBytes.Length + 1);
                writer.WriteBytes(stringBytes);
            }
            rawWriter.WriteRawTags(writer, int.MaxValue);
        }
        else
        {
            if (numTaggedFields > 0)
            {
                throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
            }
        }
    }

    /// <inheritdoc />
    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is FetchRequestMessage other && Equals(other);
    }

    /// <inheritdoc />
    public bool Equals(FetchRequestMessage? other)
    {
        if (other is null)
        {
            return false;
        }
        if (ClusterId is null)
        {
            if (other.ClusterId is not null)
            {
                return false;
            }
        }
        else
        {
            if (!ClusterId.Equals(other.ClusterId))
            {
                return false;
            }
        }
        if (ReplicaId != other.ReplicaId)
        {
            return false;
        }
        if (MaxWaitMs != other.MaxWaitMs)
        {
            return false;
        }
        if (MinBytes != other.MinBytes)
        {
            return false;
        }
        if (MaxBytes != other.MaxBytes)
        {
            return false;
        }
        if (IsolationLevel != other.IsolationLevel)
        {
            return false;
        }
        if (SessionId != other.SessionId)
        {
            return false;
        }
        if (SessionEpoch != other.SessionEpoch)
        {
            return false;
        }
        if (Topics is null)
        {
            if (other.Topics is not null)
            {
                return false;
            }
        }
        else
        {
            if (!Topics.SequenceEqual(other.Topics))
            {
                return false;
            }
        }
        if (ForgottenTopicsData is null)
        {
            if (other.ForgottenTopicsData is not null)
            {
                return false;
            }
        }
        else
        {
            if (!ForgottenTopicsData.SequenceEqual(other.ForgottenTopicsData))
            {
                return false;
            }
        }
        if (RackId is null)
        {
            if (other.RackId is not null)
            {
                return false;
            }
        }
        else
        {
            if (!RackId.Equals(other.RackId))
            {
                return false;
            }
        }
        return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        var hashCode = 0;
        hashCode = HashCode.Combine(hashCode, ClusterId, ReplicaId, MaxWaitMs, MinBytes, MaxBytes, IsolationLevel, SessionId);
        hashCode = HashCode.Combine(hashCode, SessionEpoch, Topics, ForgottenTopicsData, RackId);
        return hashCode;
    }

    /// <inheritdoc />
    public override string ToString()
    {
        return "FetchRequestMessage("
            + "ClusterId=" + (string.IsNullOrWhiteSpace(ClusterId) ? "null" : ClusterId)
            + ", ReplicaId=" + ReplicaId
            + ", MaxWaitMs=" + MaxWaitMs
            + ", MinBytes=" + MinBytes
            + ", MaxBytes=" + MaxBytes
            + ", IsolationLevel=" + IsolationLevel
            + ", SessionId=" + SessionId
            + ", SessionEpoch=" + SessionEpoch
            + ", Topics=" + Topics.DeepToString()
            + ", ForgottenTopicsData=" + ForgottenTopicsData.DeepToString()
            + ", RackId=" + (string.IsNullOrWhiteSpace(RackId) ? "null" : RackId)
            + ")";
    }

    /// <summary>
    /// Describes the contract for message FetchTopicMessage
    /// </summary>
    public sealed partial class FetchTopicMessage: IMessage, IEquatable<FetchTopicMessage>
    {
        /// <inheritdoc />
        public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

        /// <inheritdoc />
        public int IncomingBufferLength { get; private set; } = 0;

        /// <summary>
        /// The name of the topic to fetch.
        /// </summary>
        public string Topic { get; set; } = string.Empty;

        /// <summary>
        /// The unique topic ID
        /// </summary>
        public Guid TopicId { get; set; } = Guid.Empty;

        /// <summary>
        /// The partitions to fetch.
        /// </summary>
        public List<FetchPartitionMessage> Partitions { get; set; } = new ();

        /// <summary>
        /// The basic constructor of the message FetchTopicMessage
        /// </summary>
        public FetchTopicMessage()
        {
        }

        /// <summary>
        /// Base constructor for deserializing message FetchTopicMessage
        /// </summary>
        public FetchTopicMessage(ref BufferReader reader, ApiVersion version)
            : this()
        {
            IncomingBufferLength = reader.Length;
            Read(ref reader, version);
        }

        /// <inheritdoc />
        public void Read(ref BufferReader reader, ApiVersion version)
        {
            if (version > ApiVersion.Version13)
            {
                throw new UnsupportedVersionException($"Can't read version {version} of FetchTopicMessage");
            }
            if (version <= ApiVersion.Version12)
            {
                int length;
                if (version >= ApiVersion.Version12)
                {
                    length = reader.ReadVarUInt() - 1;
                }
                else
                {
                    length = reader.ReadShort();
                }
                if (length < 0)
                {
                    throw new Exception("non-nullable field Topic was serialized as null");
                }
                else if (length > 0x7fff)
                {
                    throw new Exception($"string field Topic had invalid length {length}");
                }
                else
                {
                    Topic = reader.ReadString(length);
                }
            }
            else
            {
                Topic = string.Empty;
            }
            if (version >= ApiVersion.Version13)
            {
                TopicId = reader.ReadGuid();
            }
            else
            {
                TopicId = Guid.Empty;
            }
            {
                if (version >= ApiVersion.Version12)
                {
                    int arrayLength;
                    arrayLength = reader.ReadVarUInt() - 1;
                    if (arrayLength < 0)
                    {
                        throw new Exception("non-nullable field Partitions was serialized as null");
                    }
                    else
                    {
                        var newCollection = new List<FetchPartitionMessage>(arrayLength);
                        for (var i = 0; i < arrayLength; i++)
                        {
                            newCollection.Add(new FetchPartitionMessage(ref reader, version));
                        }
                        Partitions = newCollection;
                    }
                }
                else
                {
                    int arrayLength;
                    arrayLength = reader.ReadInt();
                    if (arrayLength < 0)
                    {
                        throw new Exception("non-nullable field Partitions was serialized as null");
                    }
                    else
                    {
                        var newCollection = new List<FetchPartitionMessage>(arrayLength);
                        for (var i = 0; i < arrayLength; i++)
                        {
                            newCollection.Add(new FetchPartitionMessage(ref reader, version));
                        }
                        Partitions = newCollection;
                    }
                }
            }
            UnknownTaggedFields = null;
            if (version >= ApiVersion.Version12)
            {
                var numTaggedFields = reader.ReadVarUInt();
                for (var t = 0; t < numTaggedFields; t++)
                {
                    var tag = reader.ReadVarUInt();
                    var size = reader.ReadVarUInt();
                    switch (tag)
                    {
                        default:
                            UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                            break;
                    }
                }
            }
        }

        /// <inheritdoc />
        public void Write(BufferWriter writer, ApiVersion version)
        {
            var numTaggedFields = 0;
            if (version <= ApiVersion.Version12)
            {
                {
                    var stringBytes = Encoding.UTF8.GetBytes(Topic);
                    if (version >= ApiVersion.Version12)
                    {
                        writer.WriteVarUInt(stringBytes.Length + 1);
                    }
                    else
                    {
                        writer.WriteShort((short)stringBytes.Length);
                    }
                    writer.WriteBytes(stringBytes);
                }
            }
            if (version >= ApiVersion.Version13)
            {
                writer.WriteGuid(TopicId);
            }
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(Partitions.Count + 1);
                foreach (var element in Partitions)
                {
                    element.Write(writer, version);
                }
            }
            else
            {
                writer.WriteInt(Partitions.Count);
                foreach (var element in Partitions)
                {
                    element.Write(writer, version);
                }
            }
            var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
            numTaggedFields += rawWriter.FieldsCount;
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(numTaggedFields);
                rawWriter.WriteRawTags(writer, int.MaxValue);
            }
            else
            {
                if (numTaggedFields > 0)
                {
                    throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
                }
            }
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return ReferenceEquals(this, obj) || obj is FetchTopicMessage other && Equals(other);
        }

        /// <inheritdoc />
        public bool Equals(FetchTopicMessage? other)
        {
            if (other is null)
            {
                return false;
            }
            if (Topic is null)
            {
                if (other.Topic is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Topic.Equals(other.Topic))
                {
                    return false;
                }
            }
            if (!TopicId.Equals(other.TopicId))
            {
                return false;
            }
            if (Partitions is null)
            {
                if (other.Partitions is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Partitions.SequenceEqual(other.Partitions))
                {
                    return false;
                }
            }
            return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            var hashCode = 0;
            hashCode = HashCode.Combine(hashCode, Topic, TopicId, Partitions);
            return hashCode;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return "FetchTopicMessage("
                + "Topic=" + (string.IsNullOrWhiteSpace(Topic) ? "null" : Topic)
                + ", TopicId=" + TopicId
                + ", Partitions=" + Partitions.DeepToString()
                + ")";
        }
    }

    /// <summary>
    /// Describes the contract for message FetchPartitionMessage
    /// </summary>
    public sealed partial class FetchPartitionMessage: IMessage, IEquatable<FetchPartitionMessage>
    {
        /// <inheritdoc />
        public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

        /// <inheritdoc />
        public int IncomingBufferLength { get; private set; } = 0;

        /// <summary>
        /// The partition index.
        /// </summary>
        public int Partition { get; set; } = 0;

        /// <summary>
        /// The current leader epoch of the partition.
        /// </summary>
        public int CurrentLeaderEpoch { get; set; } = -1;

        /// <summary>
        /// The message offset.
        /// </summary>
        public long FetchOffset { get; set; } = 0;

        /// <summary>
        /// The epoch of the last fetched record or -1 if there is none
        /// </summary>
        public int LastFetchedEpoch { get; set; } = -1;

        /// <summary>
        /// The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower.
        /// </summary>
        public long LogStartOffset { get; set; } = -1;

        /// <summary>
        /// The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored.
        /// </summary>
        public int PartitionMaxBytes { get; set; } = 0;

        /// <summary>
        /// The basic constructor of the message FetchPartitionMessage
        /// </summary>
        public FetchPartitionMessage()
        {
        }

        /// <summary>
        /// Base constructor for deserializing message FetchPartitionMessage
        /// </summary>
        public FetchPartitionMessage(ref BufferReader reader, ApiVersion version)
            : this()
        {
            IncomingBufferLength = reader.Length;
            Read(ref reader, version);
        }

        /// <inheritdoc />
        public void Read(ref BufferReader reader, ApiVersion version)
        {
            if (version > ApiVersion.Version13)
            {
                throw new UnsupportedVersionException($"Can't read version {version} of FetchPartitionMessage");
            }
            Partition = reader.ReadInt();
            if (version >= ApiVersion.Version9)
            {
                CurrentLeaderEpoch = reader.ReadInt();
            }
            else
            {
                CurrentLeaderEpoch = -1;
            }
            FetchOffset = reader.ReadLong();
            if (version >= ApiVersion.Version12)
            {
                LastFetchedEpoch = reader.ReadInt();
            }
            else
            {
                LastFetchedEpoch = -1;
            }
            if (version >= ApiVersion.Version5)
            {
                LogStartOffset = reader.ReadLong();
            }
            else
            {
                LogStartOffset = -1;
            }
            PartitionMaxBytes = reader.ReadInt();
            UnknownTaggedFields = null;
            if (version >= ApiVersion.Version12)
            {
                var numTaggedFields = reader.ReadVarUInt();
                for (var t = 0; t < numTaggedFields; t++)
                {
                    var tag = reader.ReadVarUInt();
                    var size = reader.ReadVarUInt();
                    switch (tag)
                    {
                        default:
                            UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                            break;
                    }
                }
            }
        }

        /// <inheritdoc />
        public void Write(BufferWriter writer, ApiVersion version)
        {
            var numTaggedFields = 0;
            writer.WriteInt(Partition);
            if (version >= ApiVersion.Version9)
            {
                writer.WriteInt(CurrentLeaderEpoch);
            }
            writer.WriteLong(FetchOffset);
            if (version >= ApiVersion.Version12)
            {
                writer.WriteInt(LastFetchedEpoch);
            }
            else
            {
                if (LastFetchedEpoch != -1)
                {
                    throw new UnsupportedVersionException($"Attempted to write a non-default LastFetchedEpoch at version {version}");
                }
            }
            if (version >= ApiVersion.Version5)
            {
                writer.WriteLong(LogStartOffset);
            }
            writer.WriteInt(PartitionMaxBytes);
            var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
            numTaggedFields += rawWriter.FieldsCount;
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(numTaggedFields);
                rawWriter.WriteRawTags(writer, int.MaxValue);
            }
            else
            {
                if (numTaggedFields > 0)
                {
                    throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
                }
            }
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return ReferenceEquals(this, obj) || obj is FetchPartitionMessage other && Equals(other);
        }

        /// <inheritdoc />
        public bool Equals(FetchPartitionMessage? other)
        {
            if (other is null)
            {
                return false;
            }
            if (Partition != other.Partition)
            {
                return false;
            }
            if (CurrentLeaderEpoch != other.CurrentLeaderEpoch)
            {
                return false;
            }
            if (FetchOffset != other.FetchOffset)
            {
                return false;
            }
            if (LastFetchedEpoch != other.LastFetchedEpoch)
            {
                return false;
            }
            if (LogStartOffset != other.LogStartOffset)
            {
                return false;
            }
            if (PartitionMaxBytes != other.PartitionMaxBytes)
            {
                return false;
            }
            return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            var hashCode = 0;
            hashCode = HashCode.Combine(hashCode, Partition, CurrentLeaderEpoch, FetchOffset, LastFetchedEpoch, LogStartOffset, PartitionMaxBytes);
            return hashCode;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return "FetchPartitionMessage("
                + "Partition=" + Partition
                + ", CurrentLeaderEpoch=" + CurrentLeaderEpoch
                + ", FetchOffset=" + FetchOffset
                + ", LastFetchedEpoch=" + LastFetchedEpoch
                + ", LogStartOffset=" + LogStartOffset
                + ", PartitionMaxBytes=" + PartitionMaxBytes
                + ")";
        }
    }

    /// <summary>
    /// Describes the contract for message ForgottenTopicMessage
    /// </summary>
    public sealed partial class ForgottenTopicMessage: IMessage, IEquatable<ForgottenTopicMessage>
    {
        /// <inheritdoc />
        public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

        /// <inheritdoc />
        public int IncomingBufferLength { get; private set; } = 0;

        /// <summary>
        /// The topic name.
        /// </summary>
        public string Topic { get; set; } = string.Empty;

        /// <summary>
        /// The unique topic ID
        /// </summary>
        public Guid TopicId { get; set; } = Guid.Empty;

        /// <summary>
        /// The partitions indexes to forget.
        /// </summary>
        public List<int> Partitions { get; set; } = new ();

        /// <summary>
        /// The basic constructor of the message ForgottenTopicMessage
        /// </summary>
        public ForgottenTopicMessage()
        {
        }

        /// <summary>
        /// Base constructor for deserializing message ForgottenTopicMessage
        /// </summary>
        public ForgottenTopicMessage(ref BufferReader reader, ApiVersion version)
            : this()
        {
            IncomingBufferLength = reader.Length;
            Read(ref reader, version);
        }

        /// <inheritdoc />
        public void Read(ref BufferReader reader, ApiVersion version)
        {
            if (version > ApiVersion.Version13)
            {
                throw new UnsupportedVersionException($"Can't read version {version} of ForgottenTopicMessage");
            }
            if (version <= ApiVersion.Version12)
            {
                int length;
                if (version >= ApiVersion.Version12)
                {
                    length = reader.ReadVarUInt() - 1;
                }
                else
                {
                    length = reader.ReadShort();
                }
                if (length < 0)
                {
                    throw new Exception("non-nullable field Topic was serialized as null");
                }
                else if (length > 0x7fff)
                {
                    throw new Exception($"string field Topic had invalid length {length}");
                }
                else
                {
                    Topic = reader.ReadString(length);
                }
            }
            else
            {
                Topic = string.Empty;
            }
            if (version >= ApiVersion.Version13)
            {
                TopicId = reader.ReadGuid();
            }
            else
            {
                TopicId = Guid.Empty;
            }
            {
                int arrayLength;
                if (version >= ApiVersion.Version12)
                {
                    arrayLength = reader.ReadVarUInt() - 1;
                }
                else
                {
                    arrayLength = reader.ReadInt();
                }
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field Partitions was serialized as null");
                }
                else
                {
                    var newCollection = new List<int>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(reader.ReadInt());
                    }
                    Partitions = newCollection;
                }
            }
            UnknownTaggedFields = null;
            if (version >= ApiVersion.Version12)
            {
                var numTaggedFields = reader.ReadVarUInt();
                for (var t = 0; t < numTaggedFields; t++)
                {
                    var tag = reader.ReadVarUInt();
                    var size = reader.ReadVarUInt();
                    switch (tag)
                    {
                        default:
                            UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                            break;
                    }
                }
            }
        }

        /// <inheritdoc />
        public void Write(BufferWriter writer, ApiVersion version)
        {
            if (version < ApiVersion.Version7)
            {
                throw new UnsupportedVersionException($"Can't write version {version} of ForgottenTopicMessage");
            }
            var numTaggedFields = 0;
            if (version <= ApiVersion.Version12)
            {
                {
                    var stringBytes = Encoding.UTF8.GetBytes(Topic);
                    if (version >= ApiVersion.Version12)
                    {
                        writer.WriteVarUInt(stringBytes.Length + 1);
                    }
                    else
                    {
                        writer.WriteShort((short)stringBytes.Length);
                    }
                    writer.WriteBytes(stringBytes);
                }
            }
            if (version >= ApiVersion.Version13)
            {
                writer.WriteGuid(TopicId);
            }
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(Partitions.Count + 1);
            }
            else
            {
                writer.WriteInt(Partitions.Count);
            }
            foreach (var element in Partitions)
            {
                writer.WriteInt(element);
            }
            var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
            numTaggedFields += rawWriter.FieldsCount;
            if (version >= ApiVersion.Version12)
            {
                writer.WriteVarUInt(numTaggedFields);
                rawWriter.WriteRawTags(writer, int.MaxValue);
            }
            else
            {
                if (numTaggedFields > 0)
                {
                    throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
                }
            }
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return ReferenceEquals(this, obj) || obj is ForgottenTopicMessage other && Equals(other);
        }

        /// <inheritdoc />
        public bool Equals(ForgottenTopicMessage? other)
        {
            if (other is null)
            {
                return false;
            }
            if (Topic is null)
            {
                if (other.Topic is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Topic.Equals(other.Topic))
                {
                    return false;
                }
            }
            if (!TopicId.Equals(other.TopicId))
            {
                return false;
            }
            if (Partitions is null)
            {
                if (other.Partitions is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Partitions.SequenceEqual(other.Partitions))
                {
                    return false;
                }
            }
            return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            var hashCode = 0;
            hashCode = HashCode.Combine(hashCode, Topic, TopicId, Partitions);
            return hashCode;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return "ForgottenTopicMessage("
                + "Topic=" + (string.IsNullOrWhiteSpace(Topic) ? "null" : Topic)
                + ", TopicId=" + TopicId
                + ", Partitions=" + Partitions.DeepToString()
                + ")";
        }
    }
}
