//  This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// 
//  PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com
// 
//  Copyright ©  2022 Aleksey Kalduzov. All rights reserved
// 
//  Author: Aleksey Kalduzov
//  Email: alexei.kalduzov@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      https://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
// <auto-generated> THIS CODE IS AUTOMATICALLY GENERATED.  DO NOT EDIT. </auto-generated>

// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedType.Global
// ReSharper disable UnusedMember.Global
// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable PartialTypeWithSinglePart

#nullable enable

using NKafka.Exceptions;
using NKafka.Protocol;
using NKafka.Protocol.Buffers;
using NKafka.Protocol.Extensions;
using NKafka.Protocol.Records;
using System.Text;

namespace NKafka.Messages;

/// <summary>
/// Describes the contract for message ListOffsetsRequestMessage
/// </summary>
public sealed partial class ListOffsetsRequestMessage: IRequestMessage, IEquatable<ListOffsetsRequestMessage>
{
    /// <inheritdoc />
    public ApiKeys ApiKey => ApiKeys.ListOffsets;

    /// <summary>
    /// Indicates whether the request is accessed by any broker or only by the controller
    /// </summary>
    public const bool ONLY_CONTROLLER = false;

    /// <inheritdoc />
    public bool OnlyController => ONLY_CONTROLLER;

    /// <inheritdoc />
    public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

    /// <inheritdoc />
    public int IncomingBufferLength { get; private set; } = 0;

    /// <summary>
    /// The broker ID of the requestor, or -1 if this request is being made by a normal consumer.
    /// </summary>
    public int ReplicaId { get; set; } = 0;

    /// <summary>
    /// This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records
    /// </summary>
    public sbyte IsolationLevel { get; set; } = 0;

    /// <summary>
    /// Each topic in the request.
    /// </summary>
    public List<ListOffsetsTopicMessage> Topics { get; set; } = new ();

    /// <summary>
    /// The basic constructor of the message ListOffsetsRequestMessage
    /// </summary>
    public ListOffsetsRequestMessage()
    {
    }

    /// <summary>
    /// Base constructor for deserializing message ListOffsetsRequestMessage
    /// </summary>
    public ListOffsetsRequestMessage(ref BufferReader reader, ApiVersion version)
        : this()
    {
        IncomingBufferLength = reader.Length;
        Read(ref reader, version);
    }

    /// <inheritdoc />
    public void Read(ref BufferReader reader, ApiVersion version)
    {
        ReplicaId = reader.ReadInt();
        if (version >= ApiVersion.Version2)
        {
            IsolationLevel = reader.ReadSByte();
        }
        else
        {
            IsolationLevel = 0;
        }
        {
            if (version >= ApiVersion.Version6)
            {
                int arrayLength;
                arrayLength = reader.ReadVarUInt() - 1;
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field Topics was serialized as null");
                }
                else
                {
                    var newCollection = new List<ListOffsetsTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new ListOffsetsTopicMessage(ref reader, version));
                    }
                    Topics = newCollection;
                }
            }
            else
            {
                int arrayLength;
                arrayLength = reader.ReadInt();
                if (arrayLength < 0)
                {
                    throw new Exception("non-nullable field Topics was serialized as null");
                }
                else
                {
                    var newCollection = new List<ListOffsetsTopicMessage>(arrayLength);
                    for (var i = 0; i < arrayLength; i++)
                    {
                        newCollection.Add(new ListOffsetsTopicMessage(ref reader, version));
                    }
                    Topics = newCollection;
                }
            }
        }
        UnknownTaggedFields = null;
        if (version >= ApiVersion.Version6)
        {
            var numTaggedFields = reader.ReadVarUInt();
            for (var t = 0; t < numTaggedFields; t++)
            {
                var tag = reader.ReadVarUInt();
                var size = reader.ReadVarUInt();
                switch (tag)
                {
                    default:
                        UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                        break;
                }
            }
        }
    }

    /// <inheritdoc />
    public void Write(BufferWriter writer, ApiVersion version)
    {
        var numTaggedFields = 0;
        writer.WriteInt(ReplicaId);
        if (version >= ApiVersion.Version2)
        {
            writer.WriteSByte(IsolationLevel);
        }
        else
        {
            if (IsolationLevel != 0)
            {
                throw new UnsupportedVersionException($"Attempted to write a non-default IsolationLevel at version {version}");
            }
        }
        if (version >= ApiVersion.Version6)
        {
            writer.WriteVarUInt(Topics.Count + 1);
            foreach (var element in Topics)
            {
                element.Write(writer, version);
            }
        }
        else
        {
            writer.WriteInt(Topics.Count);
            foreach (var element in Topics)
            {
                element.Write(writer, version);
            }
        }
        var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
        numTaggedFields += rawWriter.FieldsCount;
        if (version >= ApiVersion.Version6)
        {
            writer.WriteVarUInt(numTaggedFields);
            rawWriter.WriteRawTags(writer, int.MaxValue);
        }
        else
        {
            if (numTaggedFields > 0)
            {
                throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
            }
        }
    }

    /// <inheritdoc />
    public override bool Equals(object? obj)
    {
        return ReferenceEquals(this, obj) || obj is ListOffsetsRequestMessage other && Equals(other);
    }

    /// <inheritdoc />
    public bool Equals(ListOffsetsRequestMessage? other)
    {
        if (other is null)
        {
            return false;
        }
        if (ReplicaId != other.ReplicaId)
        {
            return false;
        }
        if (IsolationLevel != other.IsolationLevel)
        {
            return false;
        }
        if (Topics is null)
        {
            if (other.Topics is not null)
            {
                return false;
            }
        }
        else
        {
            if (!Topics.SequenceEqual(other.Topics))
            {
                return false;
            }
        }
        return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
    }

    /// <inheritdoc />
    public override int GetHashCode()
    {
        var hashCode = 0;
        hashCode = HashCode.Combine(hashCode, ReplicaId, IsolationLevel, Topics);
        return hashCode;
    }

    /// <inheritdoc />
    public override string ToString()
    {
        return "ListOffsetsRequestMessage("
            + "ReplicaId=" + ReplicaId
            + ", IsolationLevel=" + IsolationLevel
            + ", Topics=" + Topics.DeepToString()
            + ")";
    }

    /// <summary>
    /// Describes the contract for message ListOffsetsTopicMessage
    /// </summary>
    public sealed partial class ListOffsetsTopicMessage: IMessage, IEquatable<ListOffsetsTopicMessage>
    {
        /// <inheritdoc />
        public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

        /// <inheritdoc />
        public int IncomingBufferLength { get; private set; } = 0;

        /// <summary>
        /// The topic name.
        /// </summary>
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Each partition in the request.
        /// </summary>
        public List<ListOffsetsPartitionMessage> Partitions { get; set; } = new ();

        /// <summary>
        /// The basic constructor of the message ListOffsetsTopicMessage
        /// </summary>
        public ListOffsetsTopicMessage()
        {
        }

        /// <summary>
        /// Base constructor for deserializing message ListOffsetsTopicMessage
        /// </summary>
        public ListOffsetsTopicMessage(ref BufferReader reader, ApiVersion version)
            : this()
        {
            IncomingBufferLength = reader.Length;
            Read(ref reader, version);
        }

        /// <inheritdoc />
        public void Read(ref BufferReader reader, ApiVersion version)
        {
            if (version > ApiVersion.Version7)
            {
                throw new UnsupportedVersionException($"Can't read version {version} of ListOffsetsTopicMessage");
            }
            {
                int length;
                if (version >= ApiVersion.Version6)
                {
                    length = reader.ReadVarUInt() - 1;
                }
                else
                {
                    length = reader.ReadShort();
                }
                if (length < 0)
                {
                    throw new Exception("non-nullable field Name was serialized as null");
                }
                else if (length > 0x7fff)
                {
                    throw new Exception($"string field Name had invalid length {length}");
                }
                else
                {
                    Name = reader.ReadString(length);
                }
            }
            {
                if (version >= ApiVersion.Version6)
                {
                    int arrayLength;
                    arrayLength = reader.ReadVarUInt() - 1;
                    if (arrayLength < 0)
                    {
                        throw new Exception("non-nullable field Partitions was serialized as null");
                    }
                    else
                    {
                        var newCollection = new List<ListOffsetsPartitionMessage>(arrayLength);
                        for (var i = 0; i < arrayLength; i++)
                        {
                            newCollection.Add(new ListOffsetsPartitionMessage(ref reader, version));
                        }
                        Partitions = newCollection;
                    }
                }
                else
                {
                    int arrayLength;
                    arrayLength = reader.ReadInt();
                    if (arrayLength < 0)
                    {
                        throw new Exception("non-nullable field Partitions was serialized as null");
                    }
                    else
                    {
                        var newCollection = new List<ListOffsetsPartitionMessage>(arrayLength);
                        for (var i = 0; i < arrayLength; i++)
                        {
                            newCollection.Add(new ListOffsetsPartitionMessage(ref reader, version));
                        }
                        Partitions = newCollection;
                    }
                }
            }
            UnknownTaggedFields = null;
            if (version >= ApiVersion.Version6)
            {
                var numTaggedFields = reader.ReadVarUInt();
                for (var t = 0; t < numTaggedFields; t++)
                {
                    var tag = reader.ReadVarUInt();
                    var size = reader.ReadVarUInt();
                    switch (tag)
                    {
                        default:
                            UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                            break;
                    }
                }
            }
        }

        /// <inheritdoc />
        public void Write(BufferWriter writer, ApiVersion version)
        {
            var numTaggedFields = 0;
            {
                var stringBytes = Encoding.UTF8.GetBytes(Name);
                if (version >= ApiVersion.Version6)
                {
                    writer.WriteVarUInt(stringBytes.Length + 1);
                }
                else
                {
                    writer.WriteShort((short)stringBytes.Length);
                }
                writer.WriteBytes(stringBytes);
            }
            if (version >= ApiVersion.Version6)
            {
                writer.WriteVarUInt(Partitions.Count + 1);
                foreach (var element in Partitions)
                {
                    element.Write(writer, version);
                }
            }
            else
            {
                writer.WriteInt(Partitions.Count);
                foreach (var element in Partitions)
                {
                    element.Write(writer, version);
                }
            }
            var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
            numTaggedFields += rawWriter.FieldsCount;
            if (version >= ApiVersion.Version6)
            {
                writer.WriteVarUInt(numTaggedFields);
                rawWriter.WriteRawTags(writer, int.MaxValue);
            }
            else
            {
                if (numTaggedFields > 0)
                {
                    throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
                }
            }
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return ReferenceEquals(this, obj) || obj is ListOffsetsTopicMessage other && Equals(other);
        }

        /// <inheritdoc />
        public bool Equals(ListOffsetsTopicMessage? other)
        {
            if (other is null)
            {
                return false;
            }
            if (Name is null)
            {
                if (other.Name is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Name.Equals(other.Name))
                {
                    return false;
                }
            }
            if (Partitions is null)
            {
                if (other.Partitions is not null)
                {
                    return false;
                }
            }
            else
            {
                if (!Partitions.SequenceEqual(other.Partitions))
                {
                    return false;
                }
            }
            return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            var hashCode = 0;
            hashCode = HashCode.Combine(hashCode, Name, Partitions);
            return hashCode;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return "ListOffsetsTopicMessage("
                + "Name=" + (string.IsNullOrWhiteSpace(Name) ? "null" : Name)
                + ", Partitions=" + Partitions.DeepToString()
                + ")";
        }
    }

    /// <summary>
    /// Describes the contract for message ListOffsetsPartitionMessage
    /// </summary>
    public sealed partial class ListOffsetsPartitionMessage: IMessage, IEquatable<ListOffsetsPartitionMessage>
    {
        /// <inheritdoc />
        public List<TaggedField>? UnknownTaggedFields { get; set; } = null;

        /// <inheritdoc />
        public int IncomingBufferLength { get; private set; } = 0;

        /// <summary>
        /// The partition index.
        /// </summary>
        public int PartitionIndex { get; set; } = 0;

        /// <summary>
        /// The current leader epoch.
        /// </summary>
        public int CurrentLeaderEpoch { get; set; } = -1;

        /// <summary>
        /// The current timestamp.
        /// </summary>
        public long Timestamp { get; set; } = 0;

        /// <summary>
        /// The maximum number of offsets to report.
        /// </summary>
        public int MaxNumOffsets { get; set; } = 1;

        /// <summary>
        /// The basic constructor of the message ListOffsetsPartitionMessage
        /// </summary>
        public ListOffsetsPartitionMessage()
        {
        }

        /// <summary>
        /// Base constructor for deserializing message ListOffsetsPartitionMessage
        /// </summary>
        public ListOffsetsPartitionMessage(ref BufferReader reader, ApiVersion version)
            : this()
        {
            IncomingBufferLength = reader.Length;
            Read(ref reader, version);
        }

        /// <inheritdoc />
        public void Read(ref BufferReader reader, ApiVersion version)
        {
            if (version > ApiVersion.Version7)
            {
                throw new UnsupportedVersionException($"Can't read version {version} of ListOffsetsPartitionMessage");
            }
            PartitionIndex = reader.ReadInt();
            if (version >= ApiVersion.Version4)
            {
                CurrentLeaderEpoch = reader.ReadInt();
            }
            else
            {
                CurrentLeaderEpoch = -1;
            }
            Timestamp = reader.ReadLong();
            if (version <= ApiVersion.Version0)
            {
                MaxNumOffsets = reader.ReadInt();
            }
            else
            {
                MaxNumOffsets = 1;
            }
            UnknownTaggedFields = null;
            if (version >= ApiVersion.Version6)
            {
                var numTaggedFields = reader.ReadVarUInt();
                for (var t = 0; t < numTaggedFields; t++)
                {
                    var tag = reader.ReadVarUInt();
                    var size = reader.ReadVarUInt();
                    switch (tag)
                    {
                        default:
                            UnknownTaggedFields = reader.ReadUnknownTaggedField(UnknownTaggedFields, tag, size);
                            break;
                    }
                }
            }
        }

        /// <inheritdoc />
        public void Write(BufferWriter writer, ApiVersion version)
        {
            var numTaggedFields = 0;
            writer.WriteInt(PartitionIndex);
            if (version >= ApiVersion.Version4)
            {
                writer.WriteInt(CurrentLeaderEpoch);
            }
            writer.WriteLong(Timestamp);
            if (version <= ApiVersion.Version0)
            {
                writer.WriteInt(MaxNumOffsets);
            }
            else
            {
                if (MaxNumOffsets != 1)
                {
                    throw new UnsupportedVersionException($"Attempted to write a non-default MaxNumOffsets at version {version}");
                }
            }
            var rawWriter = RawTaggedFieldWriter.ForFields(UnknownTaggedFields);
            numTaggedFields += rawWriter.FieldsCount;
            if (version >= ApiVersion.Version6)
            {
                writer.WriteVarUInt(numTaggedFields);
                rawWriter.WriteRawTags(writer, int.MaxValue);
            }
            else
            {
                if (numTaggedFields > 0)
                {
                    throw new UnsupportedVersionException($"Tagged fields were set, but version {version} of this message does not support them.");
                }
            }
        }

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {
            return ReferenceEquals(this, obj) || obj is ListOffsetsPartitionMessage other && Equals(other);
        }

        /// <inheritdoc />
        public bool Equals(ListOffsetsPartitionMessage? other)
        {
            if (other is null)
            {
                return false;
            }
            if (PartitionIndex != other.PartitionIndex)
            {
                return false;
            }
            if (CurrentLeaderEpoch != other.CurrentLeaderEpoch)
            {
                return false;
            }
            if (Timestamp != other.Timestamp)
            {
                return false;
            }
            if (MaxNumOffsets != other.MaxNumOffsets)
            {
                return false;
            }
            return UnknownTaggedFields.CompareRawTaggedFields(other.UnknownTaggedFields);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            var hashCode = 0;
            hashCode = HashCode.Combine(hashCode, PartitionIndex, CurrentLeaderEpoch, Timestamp, MaxNumOffsets);
            return hashCode;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return "ListOffsetsPartitionMessage("
                + "PartitionIndex=" + PartitionIndex
                + ", CurrentLeaderEpoch=" + CurrentLeaderEpoch
                + ", Timestamp=" + Timestamp
                + ", MaxNumOffsets=" + MaxNumOffsets
                + ")";
        }
    }
}
